<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <canvas id="gameCanvas" width="700" height="500"></canvas>
  <p>↑: 前進</p>
  <p>←→: 旋回</p>
  <p>SPACE: 発射</p>
  <p>R: リスタート</p>
  <script src="./setupAsteroid.js"></script>
  <script>
    const FPS = 30; // frames per second
    const FRICTION = 0.7; // friction coefficient of space (0 = no friction, 1 = lots of friction)

    const GAME_LIVES = 3; // staring number of lives

    const LASER_DIST = 0.6; // max distance laser can travel as fraction of screen width
    const LASER_MAX = 10; // maximum number of lasers on screen at once
    const LASER_SPD = 500; // speed of lasers in pixeld per second
    const LASER_EXPLODE_DUR = 0.1; // duration of the lasers explosion in seconds 

    const ROIDS_JAG = 0.2; // jaggedness of the asteroids (0 = none, 1 = lots)
    const ROIDS_SIZE = 100; // stargin size of asteroids in pixels
    const ROIDS_SPD = 50; // max starting speed of asteroids in pixelds per second
    const ROIDS_NUM = 1; // stargin number of asteroids
    const ROIDS_VERT = 10; // average numb er of vertiuces on each asteroids 

    const SHIP_BLINK_DUR = 0.1; // duration of the ship blink during invisibility in second
    const SHIP_EXPLODE_DUR = 0.3; // duration of the ship explosion
    const SHIP_INV_DUR = 3; // duration of the ship' invisibility second
    const SHIP_SIZE = 30; // ship height in pixels
    const SHIP_TURN_SPD = 360; // turn speed in degree second
    const SHIP_THRUST = 5; // acceletation of the ship in pixels per second per second

    const SHOW_BOUNDING = false; // show or hide collision bounding
    const SHOW_CENTRE_DOT = false; // show or hide ship's centre dot 

    const TEXT_FADE_TIME = 2.5; // text fade time in seconds
    const TEXT_SIZE = 40; // text font height in pixels

    /** @type {HTMLCanvasElement} */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // set up the game parameters
    let level, ship, roids, levelText, levelTextAlpha;
    newGame();

    // set up event handlers
    document.addEventListener("keydown", keyDown);
    document.addEventListener("keyup", keyUp);

    
    // initialize the timer variables and start the animation
    let fps, fpsInterval, startTime, now, then, elapsed;

    startAnimating(FPS);

    function startAnimating(fps) {
      fpsInterval = 1000 / fps;
      then = Date.now();
      startTime = then;
      animate();
    }

    function animate() {
      // request another frame

      requestAnimationFrame(animate);

      // calc elapsed time since last loop

      now = Date.now();
      elapsed = now - then;

      // if enough time has elapsed, draw the next frame

      if (elapsed > fpsInterval) {

        // Get ready for next frame by setting then=now, but also adjust for your
        // specified fpsInterval not being a multiple of RAF's interval (16.7ms)
        then = now - (elapsed % fpsInterval);

        // Put your drawing code here
        update();
      }

    }

    function createAsteroidBelt() {
      const _roids = [];
      let x;
      let y

      [...Array(ROIDS_NUM + level)].forEach(() => {
        do {
          x = Math.floor(Math.random() * canvas.width);
          y = Math.floor(Math.random() * canvas.height);
        } while (
          distBetweenPoints(ship.x, ship.y, x, y) < ROIDS_SIZE * 2 + ship.r
        );
        _roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE / 2) ));
      });

      return _roids;
    }

    function destroyAsteroid(index, isExplode) {
      const x = roids[index].x;
      const y = roids[index].y;
      const r = roids[index].r;

      // destroy the parent asteroid
      roids.splice(index, 1);

      // if(isExplode) return;

      // split the asteroid in two it necessary
      if(r == Math.ceil(ROIDS_SIZE / 2)) {
        roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE / 4)));
        roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE / 4)));
      } else if (r == Math.ceil(ROIDS_SIZE / 4)) {
        roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE / 8)));
        roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE / 8)));
      }

      // new level when no more asteroids
      if(roids.length == 0) {
        level++;
        newLevel();
      }
    }

    function distBetweenPoints(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    function newAsteroid(x, y, r) {
      const lvlMult = 1 + 0.1 * level;
      const _roid = {
        x: x,
        y: y,
        xv: Math.random() * ROIDS_SPD * lvlMult / FPS * (Math.random() < 0.5 ? 1 : -1),
        yv: Math.random() * ROIDS_SPD * lvlMult / FPS * (Math.random() < 0.5 ? 1 : -1),
        r: r,
        a: Math.random() * Math.PI * 2, // in radians
        vert: Math.floor(Math.random() * (ROIDS_VERT + 1) + ROIDS_VERT / 2),
        offs: [],
      };

      // create the vertex offsets array
      [...Array(_roid.vert)].map(el => {
        _roid.offs.push(Math.random() * ROIDS_JAG * 2 + 1 - ROIDS_JAG);
      });

      return _roid;
    }

    function newGame() {
      level = 0;
      lives = GAME_LIVES;
      ship = newShip();
      newLevel();
    }

    function keyDown(/** @type {KeyboardEvent} */ ev) {
      switch(ev.code) {
        case "KeyR": // space bar (allow shooting again)
          newGame();
          break;
      }

      if(ship.dead) return;

      switch(ev.code) {
        case "Space": // space bar (allow shooting again)
          shootLaser();
          break;
        case "ArrowLeft": // left arrow (rotate ship left)
          ship.rotate = SHIP_TURN_SPD / 180 * Math.PI / FPS;
          break;
        case "ArrowUp": // up arrow (ship thrusting)
          ship.thrusting = true;
          break;
        case "ArrowRight": // right arrow (rotate ship right)
          ship.rotate = -SHIP_TURN_SPD / 180 * Math.PI / FPS;
          break;
      }
    };

    function keyUp(/** @type {KeyboardEvent} */ ev) {
      if(ship.dead) return;
      
      switch(ev.code) {
        case "Space": // space bar (allow shooting again)
          ship.canShoot = true;
          break;
        case "ArrowLeft": // left arrow (rotate ship left)
          ship.rotate = 0;
          break;
        case "ArrowUp": // up arrow (ship thrusting)
          ship.thrusting = false;
          break;
        case "ArrowRight": // right arrow (rotate ship right)
          ship.rotate = 0;
          break;
      }
    }

    function explodeShip() {
      ship.explodeTime = Math.ceil(SHIP_EXPLODE_DUR * FPS);
    }

    function newGame() {
      level = 0;
      lives = GAME_LIVES;
      ship = newShip();
      newLevel();
    }

    function newLevel() {
      levelText = "LEVEL " + (level + 1);
      levelTextAlpha = 1.0;
      // setup the asteroids
      roids = createAsteroidBelt();
    }

    function newShip() {
      return {
        x: canvas.width / 2, // center
        y: canvas.height / 2, // center
        r: SHIP_SIZE / 2,
        a: 90 / 180 * Math.PI, // convert to radians
        blinkNum: Math.ceil(SHIP_INV_DUR / SHIP_BLINK_DUR),
        blinkTime: Math.ceil(SHIP_BLINK_DUR * FPS),
        canShoot: true,
        explodeTime: 0,
        dead: false,
        lasers: [],
        rotate: 0,
        thrusting: false,
        thrust: {
          x: 0,
          y: 0,
        }
      }
    }

    function shootLaser() {
      // create the laser object
      if(ship.canShoot && ship.lasers.length < LASER_MAX) {
        ship.lasers.push({ // from the nose of the ship
          x: ship.x + 4 / 3 * ship.r * Math.cos(ship.a),
          y: ship.y - 4 / 3 * ship.r * Math.sin(ship.a),
          xv: LASER_SPD * Math.cos(ship.a) / FPS,
          yv: -LASER_SPD * Math.sin(ship.a) / FPS,
          r: 0,
          dist: 0,
          explodeTime: 0,
        })
      }
      // prevent further shooting
      ship.canShoot = false;
    }

    function handleEdgeOfScreen(item) {
      if (item.x < 0 - item.r) {
        item.x = canvas.width + item.r;
      } else if (item.x > canvas.width + item.r) {
        item.x = 0 - item.r;
      }
      if (item.y < 0 - item.r) {
        item.y = canvas.height + item.r;
      } else if(item.y > canvas.height + item.r) {
        item.y = 0 - item.r;
      }
    }

    function setupShip(isExplode, blinkOn, thrusting) {
      if(ship.dead) return;

      if(!isExplode) {
        if(blinkOn) {
          // draw a triangular ship
          drawShip(ship.x, ship.y, ship.a, 20, thrusting ? "yellow" : "white");
        }

        // handle blinking
        if(ship.blinkNum > 0) {
          // reduce the blink time
          ship.blinkTime--;

          // reduce the blink num
          if(ship.blinkTime == 0) {
            ship.blinkTime = Math.ceil(SHIP_BLINK_DUR * FPS);
            ship.blinkNum--;
          }
        }
      } else {
        // draw the explosion
        ctx.fillStyle = "darkred";
        ctx.beginPath();
        ctx.arc(ship.x, ship.y, ship.r * 1.7, 0, Math.PI * 2, false);
        ctx.fill();
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(ship.x, ship.y, ship.r * 1.4, 0, Math.PI * 2, false);
        ctx.fill();
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.arc(ship.x, ship.y, ship.r * 1.1, 0, Math.PI * 2, false);
        ctx.fill();
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(ship.x, ship.y, ship.r * 0.8, 0, Math.PI * 2, false);
        ctx.fill();
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(ship.x, ship.y, ship.r * 0.5, 0, Math.PI * 2, false);
        ctx.fill();
      }

    }

    function drawShip(x, y, a, size, color) {
      ctx.strokeStyle = color;
      ctx.lineWidth = SHIP_SIZE / size;

      ctx.beginPath();
      ctx.moveTo( // nose of the ship
        x + 4 / 3 * ship.r * Math.cos(a),
        y - 4 / 3 * ship.r * Math.sin(a)
      );

      ctx.lineTo( // rear left
        x - ship.r * (2 / 3 * Math.cos(a) + Math.sin(a)),
        y + ship.r * (2 / 3 * Math.sin(a) - Math.cos(a))
      );
      ctx.lineTo( // rear right
        x - ship.r * (2 / 3 * Math.cos(a) - Math.sin(a)),
        y + ship.r * (2 / 3 * Math.sin(a) + Math.cos(a))
      );
      ctx.closePath();
      ctx.stroke();
    }

    function drawAsteroid(roids) {
      ctx.lineWidth = SHIP_SIZE / 20;
      roids.forEach(roid => {
        // draw a path
        ctx.strokeStyle = "lightslategray";
        ctx.beginPath();
        ctx.moveTo(
          // roid.x + roid.r * Math.cos(roid.a), 
          // roid.y + roid.r * Math.sin(roid.a)
          roid.x + roid.r * roid.offs[0] * Math.cos(roid.a), 
          roid.y + roid.r * roid.offs[0] * Math.sin(roid.a)
        );

        // draw the polygon
        [...Array(roid.vert)].map((_, index) => {
          ctx.lineTo(
            roid.x + roid.r * roid.offs[index] * Math.cos(roid.a + index * Math.PI * 2 / roid.vert),
            roid.y + roid.r * roid.offs[index] * Math.sin(roid.a + index * Math.PI * 2 / roid.vert)
          );
        });
        ctx.closePath();
        ctx.stroke();

        if(SHOW_BOUNDING) {
          ctx.strokeStyle = "lime";
          ctx.beginPath();
          ctx.arc(roid.x, roid.y, roid.r, 0, Math.PI * 2);
          ctx.stroke();
        }

        // move the asteroids
        roid.x += roid.xv;
        roid.y += roid.yv;

        // handle edge of screen
        handleEdgeOfScreen(roid);
      });
    }

    function gameOver() {
      ship.dead = true;
    }

    function drawText(text, textAlpha) {
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(255, 255, 255, " + textAlpha + ")";
      ctx.font = "small-caps " + TEXT_SIZE + "px sans";
      ctx.fillText(text, canvas.width / 2, canvas.height * 0.75);
    }

    function update() {
      const blinkOn = ship.blinkNum % 2 == 0;
      const exploding = ship.explodeTime > 0;

      // draw space
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // thrust the ship
      if (ship.thrusting && !ship.dead) {
        ship.thrust.x += SHIP_THRUST * Math.cos(ship.a) / FPS;
        ship.thrust.y -= SHIP_THRUST * Math.sin(ship.a) / FPS;
      } else { // not thrusting gensoku
        ship.thrust.x -= FRICTION * ship.thrust.x / FPS;
        ship.thrust.y -= FRICTION * ship.thrust.y / FPS;
      }

      // draw the ship
      setupShip(exploding, blinkOn, ship.thrusting);

      // draw the game text
      if(levelTextAlpha >= 0) {
        drawText(levelText, levelTextAlpha);
        levelTextAlpha -= (1.0 / TEXT_FADE_TIME / FPS);
      }

      // console.log(ship.dead);

      // draw the lives
      if(lives > 0) {
        [...Array(lives)].forEach((_, index) => {
          const lifeColor = exploding && index == lives - 1 ? "red" : "white";
          drawShip(SHIP_SIZE + index * SHIP_SIZE * 1.2, SHIP_SIZE, 0.5 * Math.PI, 20, lifeColor);
        });
      }

      // show bounting
      if(SHOW_BOUNDING) {
        ctx.strokeStyle = "lime";
        ctx.beginPath();
        ctx.arc(ship.x, ship.y, ship.r, 0, Math.PI * 2);
        ctx.stroke();
      }

      // rotate / move ship
      if(!exploding) {
        // check for asteroid collisions
        roids.forEach((roid, roidIndex) => {
          if(ship.blinkNum !== 0 && ship.dead) return
          if(distBetweenPoints(ship.x, ship.y, roid.x, roid.y) < ship.r + roid.r) {
            explodeShip();
            destroyAsteroid(roidIndex, true);
          }
        });

        // rotate ship
        ship.a += ship.rotate;
  
        // move the ship
        ship.x += ship.thrust.x;
        ship.y += ship.thrust.y;
      } else {
        ship.explodeTime--;
        if(ship.explodeTime == 0) {
          lives--;
          if(lives == 0) {
            ship.dead = true;
            // gameOver();
          } else {
            ship = newShip();
          }
        }
      }

      // handle edge of screen
      handleEdgeOfScreen(ship);

      // ship center dot
      if(SHOW_CENTRE_DOT) {
        ctx.fillStyle = "red";
        ctx.fillRect(ship.x - 1, ship.y - 1, 2, 2);
      }

      // draw the lasers
      [...ship.lasers].forEach(laser => {
        if(laser.explodeTime == 0) {
          ctx.fillStyle = "salmon";
          ctx.beginPath();
          ctx.arc(laser.x, laser.y, SHIP_SIZE / 15, 0, Math.PI * 2, false);
          ctx.fill();
        } else {
          // draw the explosion laser
          ctx.fillStyle = "orangered";
          ctx.beginPath();
          ctx.arc(laser.x, laser.y, ship.r * 0.75, 0, Math.PI * 2, false);
          ctx.fill();
          ctx.fillStyle = "salmon";
          ctx.beginPath();
          ctx.arc(laser.x, laser.y, ship.r * 0.5, 0, Math.PI * 2, false);
          ctx.fill();
          ctx.fillStyle = "pink";
          ctx.beginPath();
          ctx.arc(laser.x, laser.y, ship.r * 0.25, 0, Math.PI * 2, false);
          ctx.fill();
        }
      });

      // detect laser hits on asteroids
      let ax, ay, ar, lx, ly;
      roids.forEach((roid, roidIndex) => {
        // grab the asteroid properties
        ax = roid.x;
        ay = roid.y;
        ar = roid.r;

        // loop over the lasers
        ship.lasers.forEach((laser, laserIndex) => {
          // grab the laser properties
          lx = laser.x;
          ly = laser.y;

          // detect hits
          if(laser.explodeTime !== 0) return;
          if(distBetweenPoints(ax, ay, lx, ly) < ar) {
            // destroy the asteroid and activate the laser explosion
            destroyAsteroid(roidIndex);
            laser.explodeTime = Math.ceil(LASER_EXPLODE_DUR * FPS);
          }
        })
      });
    
      // move the lasers
      [...ship.lasers].forEach((laser, index) => {
        // check distance travelled
        if(laser.dist > LASER_DIST * canvas.width) {
          ship.lasers.splice(index, 1);
          return;
        }

        // handle the explosion
        if(laser.explodeTime > 0) {
          laser.explodeTime--;

          // destroy the laser after the duration is up
          if(laser.explodeTime == 0) {
             ship.lasers.splice(index, 1);
          }
        } else {
          // move the laser
          laser.x += laser.xv;
          laser.y += laser.yv;
        }


        // calculate the distance trabelled
        laser.dist += Math.sqrt(Math.pow(laser.xv, 2) + Math.pow(laser.yv, 2));

        // handle edge of screen
        handleEdgeOfScreen(laser);
      });

      // draw the asteroids
      drawAsteroid(roids);

      if(ship.dead) {
        drawText("GAME OVER", 1.0);
      }
    }

  </script>
</body>
</html>